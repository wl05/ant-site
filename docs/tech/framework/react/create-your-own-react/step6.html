<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
</body>
<script>
  function createElement(type,props,...children){
    return {
      type,
      props: {
        ...props,
        children: children.map((child)=>{
          return typeof child === "object" ? child : createTextElement(child)
        })
      }
    }
  }
  function createTextElement(text){
    return {
      type: "TEXT_ELEMENT",
      props: {
        nodeValue: text,
        children: [],
      }
    }
  }

  function createDom(fiber){
    const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
    const isProperty = key => key !== "children"
    Object.keys(fiber.props)
      .filter(isProperty)
      .forEach(name => {
        dom[name] = fiber.props[name]
      })
    return dom
  }

  function commitRoot(){
    commitWork(wipRoot,child)
    wipRoot = null
  }

  function commitWork(fiber){
    if(!fiber) {
      return
    }
    const domParent = fiber.parent.dom
    document.appendChild(fiber.dom)
    commitWork(fiber.child)
    commitWork(fiber.sibling)
  }
  function render(element,container){
      wipRoot = {
        dom: container,
        props: {
          children: [element]
        }
      }
  }
  
  let nextUnitWork = null
  let wipRoot = null
  
  function workLoop(deadline){
    let shouldYield = false
    while(nextUnitWork && !shouldYield) {
      nextUnitWork = performUnitOfWork(nextUnitWork)
      shouldYield = deadline.timeRemaining() < 1
    }
    if(!nextUnitWork && wipRoot) {
      commitRoot()
    }
    requestIdleCallback(workLoop)
  }
  requestIdleCallback(workLoop)


  function performUnitOfWork(fiber) {
    if (!fiber.dom) {
      fiber.dom = createDom(fiber)
    }
  ​
    const elements = fiber.props.children
    reconcileChildren(fiber, elements)
  ​
    if (fiber.child) {
      return fiber.child
    }
    let nextFiber = fiber
    while (nextFiber) {
      if (nextFiber.sibling) {
        return nextFiber.sibling
      }
      nextFiber = nextFiber.parent
    }
  }

  function reconcileChildren(wipFiber, elements) {
  let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
​
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
  }
}
  
  

  const Didact = {
    createElement,
    render
  }
  /** @jsx Didact.createElement */
  const element = (
    <div id="foo">
      <a>bar</a>
      <b />
    </div>
  )
  const container = document.getElementById("root")
  Didact.render(element,container)  
</script>
</html>